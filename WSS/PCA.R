# this script reads all the input and output csv files generated by 'model_runs.R' 
# and conducts Principal Component Analysis (PCA) on the timeseries out from all
# the model runs. this reduces the dimensionality of the output significantly 
# from 55 days to the number of principal components (<<55). 

# the ranges for the inputs for this model are quite wide therefore some model 
# outputs are *very* unrealistic and would be unwise to include them in the pca.
# there is therefore an opportunity for the user to specify which inputs they 
# want to ignore.

library(tidyverse)

collate.outputs = function(no.design.points){
  # extract dps into a nice dataframe/matrix ready for pca.
  
  # change wd to where design point files are stored
  setwd(folder_path_training)
  
  var.names = c('logmeanMild2R','logmeanILI2R','logmeanILI2SARI','logmeanSARI2R',
                'logmeanSARI2D','logmeanSARI2Crit','logmeanCrit2CritRecov',
                'logmeanCritRecov2Recov','Kentfac','Indiafac','Omicronfac',
                'Kenttrans','Indiatrans','vacCFR','R_decay','R_no','RawCFR_beta1',
                'RawCFR_beta2')
  
  # set up matrices
  inputs = matrix(0,no.design.points,18)
  outputs = tibble(.rows = 55) %>% mutate('day' = 0:54)
  
  for(run.no in 1:no.design.points){
    # read in input file
    input_file = read.csv(file = paste0('run',run.no,'input.csv'))
  
    # read in output file
    output_file = read_csv(file = paste0('run',run.no,'output.csv'),
                         show_col_types = FALSE)
  
    # keep useful data
    output_file = output_file[,c(9:11,14:15)]
    
    # choose output: deaths from 01/06 onwards
    output_stripped = output_file %>% 
      filter(ValueType == 'type28_death_inc_line') %>% 
      filter(`Month of Value` > 5) %>%
      mutate('day' = 0:54, .before = 1)
    
    # remove all columns except 'day' and 'value'
    output_stripped = output_stripped[,c(1,6)]
    
    colnames(output_stripped)[2] = paste0('output',run.no)
    
    inputs[run.no,] = as.matrix(input_file)
    outputs = inner_join(outputs,output_stripped,by = 'day')
  }
  
  return(list(inputs,t(outputs)))
}

extract.valid.data = function(no.valid.points){
  # extract validation points and collate them into matrix/dataframe
  
  setwd(folder_path_valid)
  
  # set up matrices for inputs and outputs
  inputs = matrix(0,no.valid.points,18)
  outputs = tibble(.rows = 55) %>% mutate('day' = 0:54)
  
  for(run.no in 1:no.valid.points){
    # read in input file
    input_file = read.csv(file = paste0('run',run.no,'input.csv'))
    
    # read in output file
    output_file = read_csv(file = paste0('run',run.no,'output.csv'),
                           show_col_types = FALSE)
    
    # keep useful data
    output_file = output_file[,c(9:11,14:15)]
    
    # choose output: deaths from 01/06 onwards
    output_stripped = output_file %>% 
      filter(ValueType == 'type28_death_inc_line') %>% 
      filter(`Month of Value` > 5) %>%
      mutate('day' = 0:54, .before = 1)
    
    # remove all columns except 'day' and 'value'
    output_stripped = output_stripped[,c(1,6)]
    
    colnames(output_stripped)[2] = paste0('output',run.no)
    
    inputs[run.no,] = as.matrix(input_file)
    outputs = inner_join(outputs,output_stripped,by = 'day')
  }
  
  inputs.outputs = cbind(inputs,t(outputs)[-1,])
  
  return(inputs.outputs)
}

pca_WSS = function(outputs,no.pcs,ignore.design.points=NULL){
  # computes pca and gives weights and basis functions of all design points
  
  # remove design points which user specifies to ignore
  if(!is.null(ignore.design.points)){
    outputs = outputs[-ignore.design.points,]
  }
  
  # conduct pca using specified number of principal components. this approximates
  # the 55 day timeseries as a linear combination of no.pcs basis functions
  pca_WSS = prcomp(outputs,rank. = no.pcs)
  basis.functions = pca_WSS$rotation
  weights = outputs%*%pca_WSS$rotation
  
  return(list(pca = pca_WSS,weights = weights,basis.functions = basis.functions,
              outputs = outputs))
}

test_pca = function(pca,output.no,return.plot = FALSE){
  # compares pca approx to true output and gives error of approximation when 
  # given a specific output number. also gives plot if requested
  
  # bring back the raw output timeseries for purposes of comparison
  outputs = pca$outputs
  no.pcs = dim(pca_WSS1$pca$rotation)[2]
  
  output_1 = outputs[output.no,] # 'true' output
  
  approximation = pca_WSS1$basis.functions[,1]*pca_WSS1$weights[output.no,"PC1"]
  for(i in 2:no.pcs){
    approximation = approximation + 
      pca_WSS1$basis.functions[,i]*pca_WSS1$weights[output.no,paste0("PC",i)]
  } # approximation using PCA
  
  # compute error
  error = sum((output_1 - approximation)^2)
  
  # plot time series with approximation
  t.series.plot = plot(x=0:54,y=output_1) + lines(x=0:54,y=approximation)
  
  if(return.plot){
    return(list(t.series.plot,error = error))
  } else{
    return(list(error = error))
  }
}

#define folder paths
folder_path_training = 'C:/Users/md624/OneDrive - University of Exeter/Microsoft/WSS/WSS-main/output_files_workflow'
folder_path_valid = 'C:/Users/md624/OneDrive - University of Exeter/Microsoft/WSS/WSS-main/output_files_valid'

# collate all the outputs together
all.inputs.outputs = collate.outputs(180)
all.inputs = all.inputs.outputs[[1]]
all.outputs = all.inputs.outputs[[2]][-1,]

# collate valid. data
validation_data = extract.valid.data(50)

sort(all.outputs[,55],decreasing = FALSE) 
# if any dps have unrealistic number of deaths then store them in 
# 'ignore.design.points' below

sort(validation_data[,73],decreasing = FALSE)
# likewise for validation points

ignore.design.points = c(130,86)
ignore.valid.points = c(21)

no.pcs = 8

pca_WSS1 = pca_WSS(all.outputs,no.pcs = no.pcs,ignore.design.points = ignore.design.points)

summary(pca_WSS1$pca)
# if necessary reduce/increase number of principal components (no.pcs) if 
# required. looking for lowest number of pcs that explain desired amount of 
# variance
